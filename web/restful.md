# RESTful API란?
RESTful architecture style을 잘 따르는 API이다. 궁극적인 목표는 '서버와 클라이언트의 독립적인 진화'이다.
서버의 변경에도 클라이언트의 변경이 필요하지 않은 상황 (또한 *vice versa*) 를 의미한다.

'독립적인 진화'를 달성하기 위한 수단은 `Uniform interface`라는 개념이며, 다른 네트워크 아키텍쳐와 REST를 차별화하는 조건이다.

# Constraints of RESTful architecture 
RESTful API는 다음의 제약 사항을 완벽하게 지켜야 한다.

## Client-Server
클라이언트-서버 구조를 가진다. 클라이언트는 서버로 요청을 보냄으로써 서비스를 트리거링하며, 대기 상태에 있던 서버는 트리거링에 반응해 서비스를 제공한다.
클라이언트는 사용자 인터페이스, 서버는 서비스 제공이라는 관심사에 따른 책임 분리를 구현한다. 
클라이언트-서버 구조는 인터페이스를 통해 통신한다. 인터페이스를 준수하는 한, 클라이언트와 서버는 독립적으로 발전할 수 있다.

## Stateless
상태 비저장적인 특성을 만족해야 한다. 클라이언트의 요청 자체(header, body, path parameter 등)에는 서버가 요청을 이해하기 위한 모든 정보를 포함해야 한다.
이 특성으로 얻을 수 있는 장점은 다음과 같다.
- 가시성 : 단일 요청이 모든 요청 정보를 포함하므로, 모니터링이 쉬움
- 안정성 : 부분 장애 복구가 쉬움
- 확장성 : 상태를 관리하지 않음으로써 단순한 구현이 가능

## Cacheable
클라이언트 캐싱을 통해 사용자가 느끼는 응답 성능을 향상시킬 수 있다. 또한, 서버와의 통신을 줄일 수 있다.

## Layered System
클라이언트와 서버 사이에는 로드 밸런서와 같은 중재자가 끼어들 수 있다. 
클라이언트는 자신이 실제 서버와 연결되었는지, 중재자와 연결되었는지 알 수 없다.
대규모 요청이 발생하는 상황에서, 서버 인스턴스를 스케일아웃하고 요청을 적절히 분산시키는 등 확장성 측면에서의 요구사항이다.

## Uniform Interface
**RESTful 아키텍쳐 스타일과 다른 네트워크 아키텍쳐를 구분짓는 가장 핵심이 되는 제약이다.**
클라이언트와 서버 간 인터페이스는 일관성이 있어야 한다는 것이다. 인터페이스 일관성을 추구하는 이유는, REST에서 강조하는 '서버와 클라이언트의 독립적인 진화'를 추구하기 위함이다. 
REST가 정의하는 일관된 인터페이스를 위한 조건은 다음과 같다.

### 리소스 식별
`URI`를 통해 고유한 리소스를 식별한다. 리소스란, '식별 가능한 무언가', 혹은 '이름을 지정할 수 있는 모든 정보'와 같은 추상적인 개념이다. 
리소스를 식별하기 위한 URI는 서버와 클라이언트의 상호작용 간에 변경되지 않아야 한다.

### Manipulation of resources through representations
리소스의 특정 시점의 상태를 '표현'하는 개체를 `Representation`이라 한다. 이 `Representation`을 전달함으로써 리소스를 조작한다.  
클라이언트는 새로운 리소스를 생성하기 위해, 이 리소스 상태를 표현하는 적절한 JSON, XML 등의 형식을 가진 `Representation`을 통해 서버로 요청한다. 
서버는 이 표현으로부터 해당 리소스를 찾아 조작한 후, 그 결과에 대한 표현을 클라이언트에게 응답한다.

### Self-descriptive message
메시지는 자기 스스로를 완전히 설명할 수 있어야 한다. 서버나 클라이언트가 변경되더라도 메시지가 그 자체로서 해석될 수 있다면 독립적인 진화가 가능할 것이기 때문이다.
HTTP의 헤더 중 `Host`, `Content-type` 등이 메시지를 스스로 설명하기 위한 목적을 가진다.  

아래 JSON 응답은 해당 메시지를 해석하기 위한 컨텐트 타입이 JSON이라는 것을 명시해주었다.
따라서 클라이언트는 JSON 문법에 해당 값을 파싱할 수 있다. 단, 클라이언트는 "id"와 "name"이 무엇을 의미하는지는 모른다. 
따라서, 이에 대한 명세를 `Link` 헤더에 포함하고, 관련된 문서를 링크로 연결함으로써, Self-descriptive message를 만들 수 있다.
```json
HTTP/1.1 200 OK
Content-Type: application/json
Link: <https://example.org/docs/customers>; rel="profile"
{ 
  "id": 1,
  "name": "Bob"
}
```

또 다른 방법으로는 [Custom media type을 정의](https://www.iana.org/assignments/media-types/media-types.xhtml)하고 문서화할 수 있다.


### HATEOAS (Hypermedia as the Engine of Application State)
HATEOAS를 직역하면 `애플리케이션 상태를 결정하는 엔진으로서의 하이퍼미디어'이다. 애플리케이션의 상태 전이는 클라이언트와 서버가 하이퍼링크를 통해 상호작용한 결과여야 한다는 의미이다.
현재 상태에 따라 다음 상태로 올 수 있는 후보들이 결정된다.

이를 실현하는 방법은 API의 응답에 현재 상태로부터 전이될 수 있는 다음 상태에 대한 정보를 함께 반환하는 것이다. 이로써 클라이언트를 올바른 다음 상태로 안내할 수 있다. 

예를 들면, `application/hal+json`이라는 미디어 타입은 JSON에 하이퍼링크를 표현하는 방법을 정의한 명세이며, 전이할 수 있는 다음 상태에 대한 링크를 포함할 수 있다. 

특정 고객의 정보를 얻기 위한 `GET /customers/{id}` API는 이후 단계에서 해당 고객의 모든 주문 목록을 받는 페이지로 전이될 수 있다고 가정하자.
`GET /customer/1` API 응답으로 아래와 같은 JSON을 받게 된다.
```json
{
    "customerId": "1",
    "customerName": "Bob",
    "companyName": "XYZ Company",
    "_links": {
      "self": {
        "href": "http://foobar.xyz/customers/1"
      },
      "allOrders": {
        "href": "http://foobar.xyz/customers/1/orders"
      }
}
``` 
`_links`라는 JSON 객체는 현재 링크와 현재 상태에서 넘어갈 수 있는 다음 상태의 링크 목록을 포함한다. `self`는 현재 링크를 의미하며, `allOrders`는 해당 고객의 모든 주문 목록을 받기 위한 URL 링크를 정의한다. 

만일 해당 리소스를 표현하기 위한 URI가 변경되는 상황이 발생했을 때, 클라이언트는 서버로부터 받은 `_links`를 참조해 올바른 다음 상태로 전이할 수 있다. 이는 서버의 URI 수정에 대해서도 클라이언트의 변경이 일어나지 않는다는 것을 의미한다.


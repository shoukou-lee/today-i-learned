1. 다음과 같이 닭, 비둘기, 날다람쥐라는 구체 클래스가 있다. 닭과 비둘기는 알을 낳고, 비둘기는 날 수 있다. 날다람쥐는 새끼를 낳고 날 수 있다. 
![IMAGE](/img/interface-and-inheritence/DEF2DB8C24584053A72FA57E10E37F85.jpg)

2. 닭과 비둘기를 조류로, 날다람쥐는 포유류로 추상화를 시도하면 아래와 같은 다이어그램으로 표현할 수 있다. 이때 문제점은 닭은 fly()라는 행위를 가지게 된다는 것이다. 현실에서 'chiken **IS-A** bird' 이지만, 주어진 객체간의 관계에서는 `is-a` 관계를 만족하지 못한다. 또한, fly()는 날다람쥐와 비둘기가 공통적으로 갖는 행위이지만 추상화되지 못하는 문제가 있다. 
![IMAGE](/img/interface-and-inheritence/C35F8A2E3B3FADEC333E0DE96A11168B.jpg)

3. FlyingAnimal(날 수 있는 동물)이라는 수퍼클래스를 만들어 날다람쥐와 비둘기의 fly()를 추상화를 한다면, 다중상속 문제가 발생한다. 만약, '날 수 있는 새', '날 수 있는 포유류'라는 두 수퍼클래스를 만드는 것은 곧 '조합 폭발' 문제가 발생한 것이다. ('곤충'을 상속하는 하위  클래스를 추가해야 하는 상황을 생각해보자.)
![IMAGE](/img/interface-and-inheritence/3347D22FB4E8D99C1A561C5A6F519297.jpg)

4. 'fly()'라는 행위를 인터페이스로 추상화하고, 구체 클래스에서 이를 구현하면 다중 상속 문제를 해결하면서, 날 수 있는 객체들의 fly()를 추상화할 수 있다. 특정 객체의 타입을 유지하면서, 추가적인 기능을 사용하고 있음을 명시하는 'mixin'을 적용한 것이다.
![IMAGE](/img/interface-and-inheritence/2BBE25356DDD6AF5A2740B49CBBAD991.jpg)

구체 클래스에서 인터페이스를 적용하는 것이 수퍼클래스를 만드는 것보다 훨씬 유연해진 것을 알 수 있다. (2 vs. 4) 또한, interface는 다중상속 문제에서 보다 자유롭다. (3 vs. 4)